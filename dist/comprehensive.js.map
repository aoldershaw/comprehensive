{"version":3,"file":"comprehensive.js","sourceRoot":"","sources":["../src/comprehensive.ts"],"names":[],"mappings":"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","sourcesContent":["// Matches 'for name1, name2, ... of/in' strings, and captures the variable name(s)\nconst FOR_REGEX = /^for\\s+([A-Za-z_\\$][A-Za-z0-9-_\\$]*(\\s*,\\s*[A-Za-z_\\$][A-Za-z0-9-_\\$]*)*)\\s+(in|of)/;\n// Matches property chains (e.g. anObject.subObject.property)\nconst FIELD_REGEX = /^[A-Za-z_$][A-Za-z0-9-_$]*(?:\\.[A-Za-z_$][A-Za-z0-9-_$]*)*/;\n\ninterface Reference {\n    parts: string[];\n    expr: string;\n}\n\nenum FieldType {\n    OF = 'of',\n    IN = 'in',\n}\n\ninterface Fields {\n    names: string[];\n    type: FieldType;\n}\n\ntype Key = string | Reference;\ntype Value = string | number | boolean | Object | Array<any>;\ntype KeyProvider = (arg: any) => string;\ntype ValueProvider = (arg: any) => Value;\ntype KeyExpression = KeyProvider | Reference | string;\ntype ValueExpression = ValueProvider | Reference | Value\n\nfunction handleReferenceFunction(ref: Reference, fields: Fields): KeyProvider | ValueProvider {\n    if(fields.type === 'in' && ref.parts.length > 1)\n        throw `You cannot traverse the key ${ref.parts[0]}`;\n    const index = fields.names.indexOf(ref.parts[0]);\n    if(index < 0) throw new Error(`Invalid field name ${ref.parts[0]}`);\n    const hasMultipleFields = fields.names.length > 1;\n    return (entry) => {\n        let cur = hasMultipleFields ? entry[index] : entry;\n        for(let i = 1; i < ref.parts.length; i++) {\n            cur = cur[ref.parts[i]];\n            if(cur === undefined) return cur;\n        }\n        return cur;\n    }\n}\n\nfunction ltrim(s: string, c: string) {\n    let i = 0;\n    const strLen = s.length;\n    while(i < strLen && s.charAt(i) === c) {\n        i++;\n    }\n    return s.substr(i);\n}\n\nfunction isFunction(o: any) {\n    return typeof o === 'function';\n}\n\nfunction obtainProvider(e: KeyExpression | ValueExpression, isReference: boolean, fields: Fields): KeyProvider | ValueProvider {\n    if(isReference) return handleReferenceFunction(<Reference> e, fields);\n    if(isFunction(e)) return <KeyProvider | ValueProvider> e;\n    return () => <string | Value> e;\n}\n\nfunction parseRef(s: string): Reference {\n    let match = FIELD_REGEX.exec(s);\n    if(match == null) throw new Error(\"Invalid reference format\");\n    return {parts: match[0].split('.'), expr: match[0]};\n}\n\nfunction parseFields(s: string): Fields {\n    let match;\n    if(s.substr(0, 4) === 'over') {\n        return {names: ['it'], type: FieldType.OF};\n    } else if((match = FOR_REGEX.exec(s)) != null) {\n        const names = match[1].split(',').map(s => s.trim());\n        const type: FieldType = match[3];\n        if(type === FieldType.IN && names.length > 1)\n            throw new Error(\"Cannot spread multiple fields with the 'in' operator\");\n        return {names, type};\n    } else {\n        throw new Error(\"Invalid iteration operator. Expecting either 'for ... of', 'for ... in', or 'over'\")\n    }\n}\n\nexport function parseExpression(strings: TemplateStringsArray, ...values: Array<any>) {\n    let s = ltrim(strings[0].trim(), '{').trim();\n    let valueIndex = 0;\n    let stringIndex = 1;\n    const hasKeyExpression = s.length === 0;\n    let key: Key;\n    if(hasKeyExpression) {\n        key = values[valueIndex++];\n        if(key == null) throw new Error(\"Expecting a key\");\n        s = strings[stringIndex++].trim();\n    } else {\n        key = parseRef(s);\n        s = s.substr(key.expr.length).trim();\n    }\n    if(s.charAt(0) !== ':') throw new Error(\"Missing ':'\");\n    s = s.substr(1).trim();\n    const hasValueExpression = s.length === 0;\n    let value: Value;\n    if(hasValueExpression) {\n        value = values[valueIndex++];\n        if(!value) throw new Error(\"Expecting a value\");\n        s = strings[stringIndex++].trim();\n    } else {\n        value = parseRef(s);\n        s = s.substr((<Reference> value).expr.length).trim();\n    }\n    const fields = parseFields(s);\n    const keyFn = <KeyProvider> obtainProvider(key, !hasKeyExpression, fields);\n    const valueFn = <ValueProvider> obtainProvider(value, !hasValueExpression, fields);\n    const list = fields.type === FieldType.OF ? values[valueIndex] : Object.keys(values[valueIndex]);\n    if(list == null || !Array.isArray(list)) throw new Error(`An invalid array was passed (provided ${list})`);\n    return {\n        keyFn,\n        valueFn,\n        list,\n    }\n}\n\nexport function toObj(strings: TemplateStringsArray, object: object): object;\nexport function toObj(strings: TemplateStringsArray, key: KeyExpression, object: object): object;\nexport function toObj(strings: TemplateStringsArray, value: ValueExpression, object: object): object;\nexport function toObj(strings: TemplateStringsArray, key: KeyExpression, value: ValueExpression, object: object): object;\n\nexport function toObj(strings: TemplateStringsArray, ...values: Array<any>): object {\n    const object = {};\n    const {keyFn, valueFn, list} = parseExpression(strings, ...values);\n    for(const entry of list) {\n        const curKey = keyFn(entry);\n        if(typeof curKey !== 'string' && typeof curKey !== 'number')\n            throw new Error('Key must be either a string or a number, not a(n) ' + typeof curKey);\n        object[curKey] = valueFn(entry);\n    }\n    return object;\n}\n\nexport function toObjSafe(strings: TemplateStringsArray, object: object): object;\nexport function toObjSafe(strings: TemplateStringsArray, key: KeyExpression, object: object): object;\nexport function toObjSafe(strings: TemplateStringsArray, value: ValueExpression, object: object): object;\nexport function toObjSafe(strings: TemplateStringsArray, key: KeyExpression, value: ValueExpression, object: object): object;\n\nexport function toObjSafe(strings: TemplateStringsArray, ...values: Array<any>): object {\n    try {\n        // @ts-ignore\n        return toObj(strings, ...values);\n    } catch(err) {\n        return null;\n    }\n}"]}