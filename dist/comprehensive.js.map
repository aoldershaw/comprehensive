{"version":3,"file":"comprehensive.js","sourceRoot":"","sources":["../src/comprehensive.ts"],"names":[],"mappings":";;AAAA,gFAAgF;AAChF,IAAM,SAAS,GAAG,gFAAgF,CAAC;AACnG,6DAA6D;AAC7D,IAAM,WAAW,GAAG,4DAA4D,CAAC;AAcjF,iCAAiC,GAAc,EAAE,UAAoB;IACjE,IAAM,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAG,KAAK,GAAG,CAAC;QAAE,MAAM,IAAI,KAAK,CAAC,wBAAsB,GAAG,CAAC,KAAK,CAAC,CAAC,CAAG,CAAC,CAAC;IACpE,IAAM,iBAAiB,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;IAChD,OAAO,UAAC,KAAK;QACT,IAAI,GAAG,GAAG,iBAAiB,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACnD,KAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACxB,IAAG,GAAG,KAAK,SAAS;gBAAE,OAAO,GAAG,CAAC;SACpC;QACD,OAAO,GAAG,CAAC;IACf,CAAC,CAAA;AACL,CAAC;AAED,eAAe,CAAS,EAAE,CAAS;IAC/B,OAAO,CAAC,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,MAAI,CAAC,MAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AAC/C,CAAC;AAED,oBAAoB,CAAM;IACtB,OAAO,OAAO,CAAC,KAAK,UAAU,CAAC;AACnC,CAAC;AAED,wBAAwB,CAAkC,EAAE,WAAoB,EAAE,UAAoB;IAClG,IAAG,WAAW;QAAE,OAAO,uBAAuB,CAAa,CAAC,EAAE,UAAU,CAAC,CAAC;IAC1E,IAAG,UAAU,CAAC,CAAC,CAAC;QAAE,OAAqC,CAAC,CAAC;IACzD,OAAO,cAAM,OAAiB,CAAC,EAAlB,CAAkB,CAAC;AACpC,CAAC;AAED,kBAAkB,CAAS;IACvB,IAAI,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAChC,IAAG,KAAK,IAAI,IAAI;QAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC9D,OAAO,EAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,EAAC,CAAC;AACxD,CAAC;AAED,yBAAyB,CAAS;IAC9B,IAAI,KAAK,CAAC;IACV,IAAG,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,EAAE;QAC1B,OAAO,CAAC,IAAI,CAAC,CAAC;KACjB;SAAM,IAAG,CAAC,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;QAC3C,IAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,EAAE,EAAR,CAAQ,CAAC,CAAC;QACrD,OAAO,KAAK,CAAC;KAChB;SAAM;QACH,MAAM,IAAI,KAAK,CAAC,gFAAgF,GAAG,CAAC,CAAC,CAAA;KACxG;AACL,CAAC;AAOD,eAAsB,OAA6B;IAAE,gBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,+BAAqB;;IACtE,IAAI,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;IAC7C,IAAI,UAAU,GAAG,CAAC,CAAC;IACnB,IAAI,WAAW,GAAG,CAAC,CAAC;IACpB,IAAM,gBAAgB,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;IACxC,IAAI,GAAQ,CAAC;IACb,IAAG,gBAAgB,EAAE;QACjB,GAAG,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QAC3B,IAAG,GAAG,IAAI,IAAI;YAAE,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;QACnD,CAAC,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;KACrC;SAAM;QACH,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;KACxC;IACD,IAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG;QAAE,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;IACvD,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IACvB,IAAM,kBAAkB,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;IAC1C,IAAI,KAAY,CAAC;IACjB,IAAG,kBAAkB,EAAE;QACnB,KAAK,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QAC7B,IAAG,CAAC,KAAK;YAAE,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;QAChD,CAAC,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;KACrC;SAAM;QACH,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACpB,CAAC,GAAG,CAAC,CAAC,MAAM,CAAc,KAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;KACxD;IACD,IAAM,UAAU,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;IACtC,IAAM,KAAK,GAAiB,cAAc,CAAC,GAAG,EAAE,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC;IAC/E,IAAM,OAAO,GAAmB,cAAc,CAAC,KAAK,EAAE,CAAC,kBAAkB,EAAE,UAAU,CAAC,CAAC;IACvF,IAAM,MAAM,GAAG,EAAE,CAAC;IAClB,IAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;IAC/B,IAAG,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;QAAE,MAAM,IAAI,KAAK,CAAC,2CAAyC,IAAI,MAAG,CAAC,CAAC;IAC3G,KAAmB,UAAI,EAAJ,aAAI,EAAJ,kBAAI,EAAJ,IAAI,EAAE;QAArB,IAAM,KAAK,aAAA;QACX,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;QAC5B,IAAG,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,QAAQ;YACvD,MAAM,IAAI,KAAK,CAAC,oDAAoD,GAAG,OAAO,MAAM,CAAC,CAAC;QAC1F,MAAM,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;KACnC;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AAvCD,sBAuCC;AAOD,mBAA0B,OAA6B;IAAE,gBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,+BAAqB;;IAC1E,IAAI;QACA,aAAa;QACb,OAAO,KAAK,gBAAC,OAAO,SAAK,MAAM,GAAE;KACpC;IAAC,OAAM,GAAG,EAAE;QACT,OAAO,IAAI,CAAC;KACf;AACL,CAAC;AAPD,8BAOC","sourcesContent":["// Matches 'for name1, name2, ... of' strings, and captures the variable name(s)\nconst FOR_REGEX = /^for\\s+([A-Za-z_\\$][A-Za-z0-9-_\\$]*(\\s*,\\s*[A-Za-z_\\$][A-Za-z0-9-_\\$]*)*)\\s+of/;\n// Matches property chains (e.g. anObject.subObject.property)\nconst FIELD_REGEX = /^[A-Za-z_$][A-Za-z0-9-_$]*(?:\\.[A-Za-z_$][A-Za-z0-9-_$]*)*/;\n\ninterface Reference {\n    parts: string[];\n    expr: string;\n}\n\ntype Key = string | Reference;\ntype Value = string | number | boolean | Object | Array<any>;\ntype KeyProvider = (arg: any) => string;\ntype ValueProvider = (arg: any) => Value;\ntype KeyExpression = KeyProvider | Reference | string;\ntype ValueExpression = ValueProvider | Reference | Value\n\nfunction handleReferenceFunction(ref: Reference, fieldNames: string[]): KeyProvider | ValueProvider {\n    const index = fieldNames.indexOf(ref.parts[0]);\n    if(index < 0) throw new Error(`Invalid field name ${ref.parts[0]}`);\n    const hasMultipleFields = fieldNames.length > 1;\n    return (entry) => {\n        let cur = hasMultipleFields ? entry[index] : entry;\n        for(let i = 1; i < ref.parts.length; i++) {\n            cur = cur[ref.parts[i]];\n            if(cur === undefined) return cur;\n        }\n        return cur;\n    }\n}\n\nfunction ltrim(s: string, c: string) {\n    return s.replace(new RegExp(`^${c}+`), '');\n}\n\nfunction isFunction(o: any) {\n    return typeof o === 'function';\n}\n\nfunction obtainProvider(e: KeyExpression | ValueExpression, isReference: boolean, fieldNames: string[]): KeyProvider | ValueProvider {\n    if(isReference) return handleReferenceFunction(<Reference> e, fieldNames);\n    if(isFunction(e)) return <KeyProvider | ValueProvider> e;\n    return () => <string | Value> e;\n}\n\nfunction parseRef(s: string): Reference {\n    let match = FIELD_REGEX.exec(s);\n    if(match == null) throw new Error(\"Invalid reference format\");\n    return {parts: match[0].split('.'), expr: match[0]};\n}\n\nfunction parseFieldNames(s: string): string[] {\n    let match;\n    if(s.substr(0, 4) === 'over') {\n        return ['it'];\n    } else if((match = FOR_REGEX.exec(s)) != null) {\n        const names = match[1].split(',').map(s => s.trim());\n        return names;\n    } else {\n        throw new Error(\"Invalid iteration operator. Expecting either 'for ... of' or 'over', provided \" + s)\n    }\n}\n\nexport function toObj(strings: TemplateStringsArray, array: Array<any>): object;\nexport function toObj(strings: TemplateStringsArray, key: KeyExpression, array: Array<any>): object;\nexport function toObj(strings: TemplateStringsArray, value: ValueExpression, array: Array<any>): object;\nexport function toObj(strings: TemplateStringsArray, key: KeyExpression, value: ValueExpression, array: Array<any>): object;\n\nexport function toObj(strings: TemplateStringsArray, ...values: Array<any>): object {\n    let s = ltrim(strings[0].trim(), '{').trim();\n    let valueIndex = 0;\n    let stringIndex = 1;\n    const hasKeyExpression = s.length === 0;\n    let key: Key;\n    if(hasKeyExpression) {\n        key = values[valueIndex++];\n        if(key == null) throw new Error(\"Expecting a key\");\n        s = strings[stringIndex++].trim();\n    } else {\n        key = parseRef(s);\n        s = s.substr(key.expr.length).trim();\n    }\n    if(s.charAt(0) !== ':') throw new Error(\"Missing ':'\");\n    s = s.substr(1).trim();\n    const hasValueExpression = s.length === 0;\n    let value: Value;\n    if(hasValueExpression) {\n        value = values[valueIndex++];\n        if(!value) throw new Error(\"Expecting a value\");\n        s = strings[stringIndex++].trim();\n    } else {\n        value = parseRef(s);\n        s = s.substr((<Reference> value).expr.length).trim();\n    }\n    const fieldNames = parseFieldNames(s);\n    const keyFn = <KeyProvider> obtainProvider(key, !hasKeyExpression, fieldNames);\n    const valueFn = <ValueProvider> obtainProvider(value, !hasValueExpression, fieldNames);\n    const object = {};\n    const list = values[valueIndex]\n    if(list == null || !Array.isArray(list)) throw new Error(`An invalid array was passed (provided ${list})`);\n    for(const entry of list) {\n        const curKey = keyFn(entry);\n        if(typeof curKey !== 'string' && typeof curKey !== 'number')\n            throw new Error('Key must be either a string or a number, not a(n) ' + typeof curKey);\n        object[curKey] = valueFn(entry);\n    }\n    return object;\n}\n\nexport function toObjSafe(strings: TemplateStringsArray, array: Array<any>): object;\nexport function toObjSafe(strings: TemplateStringsArray, key: KeyExpression, array: Array<any>): object;\nexport function toObjSafe(strings: TemplateStringsArray, value: ValueExpression, array: Array<any>): object;\nexport function toObjSafe(strings: TemplateStringsArray, key: KeyExpression, value: ValueExpression, array: Array<any>): object;\n\nexport function toObjSafe(strings: TemplateStringsArray, ...values: Array<any>): object {\n    try {\n        // @ts-ignore\n        return toObj(strings, ...values);\n    } catch(err) {\n        return null;\n    }\n}"]}